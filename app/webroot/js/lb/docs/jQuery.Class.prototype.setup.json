c({"name": "jQuery.Class.prototype.setup", "type": "function", "parents": ["jQuery.Class.prototype"], "comment": "<p>If a setup method is provided, it is called when a new \ninstances is created.  It gets passed the same arguments that\nwere given to the Class constructor function (<code> new Class( arguments ... )</code>).</p>\n\n<pre><code>$.Class(\"MyClass\",\n{\n   setup: function( val ) {\n      this.val = val;\n    }\n})\nvar mc = new MyClass(\"Check Check\")\nmc.val //-&gt; 'Check Check'\n</code></pre>\n\n<p>Setup is called before [jQuery.Class.prototype.init init].  If setup \nreturn an array, those arguments will be used for init. </p>\n\n<pre><code>$.Class(\"jQuery.Controller\",{\n  setup : function(htmlElement, rawOptions){\n    return [$(htmlElement), \n              $.extend({}, this.Class.defaults, rawOptions )] \n  }\n})\n</code></pre>\n\n<div class='whisper'>PRO TIP: \nSetup functions are used to normalize constructor arguments and provide a place for\nsetup code that extending classes don't have to remember to call _super to\nrun.\n</div>\n\n<p>Setup is not defined on $.Class itself, so calling super in inherting classes\nwill break.  Don't do the following:</p>\n\n<pre><code>$.Class(\"Thing\",{\n  setup : function(){\n    this._super(); // breaks!\n  }\n})\n</code></pre>", "ret": {"description": "<p>If an array is return, [jQuery.Class.prototype.init] is \ncalled with those arguments; otherwise, the original arguments are used.</p>", "type": "Array|undefined"}, "src": "jquery/class/class.js", "line": 675, "children": []})